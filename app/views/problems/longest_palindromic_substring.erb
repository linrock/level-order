<h1>Longest palindromic substring</h1>

<section class="problem">
  <div>
    Given a string S, find the longest substring of S that's also a
    palindrome. A palindrome is a string that's the same as when it's
    reversed.
  </div>

  <br>
  <div>
    ABCDEEEDFG
  </div>

  <div>
    Longest palindrome DEEED
  </div>
</section>

<%= solutions_table do %>
  Brute force            O(n^3)   O(1)
  Dynamic programming    O(n^2)   O(n^2)
  Central expansion      O(n^2)   O(1)
  Manacher's algorithm   O(n)     O(1)
<% end %>

<section class="solutions">
  <div class="solution">
    <h2>Solution 1: Brute force</h2>
    <div class="explanation">
      For all possible substrings, check if it's a palindrome.
      If it's a palindrome and it's longer than the currently-longest
      palindrome, save the start and end indices of the substring.
    </div>
    <%= rb_code "code/problems/longest_palindromic_substring/s1.rb" %>
    <%= complexity_table do %>
      Time   O(n^3)  Each of n^2 substrings takes O(n) time to check
      Space  O(1)    The start/end indices of the longest palindrome
    <% end %>
  </div>

  <div class="solution">
    <h2>Solution 2: Dynamic programming</h2>
    <div class="explanation">
      This improves the runtime of the brute force solution by checking
      whether a substring is a palindrome in constant time instead of
      linear time.  It saves time at the expense of space by storing
      whether a substring is a palindrome and referencing these values
      for longer substrings.
      <br><br>
      Let each value of is_pal[i][j] be
      <ul>
        <li>true when a substring S<sub>i,j</sub> is a palindrome</li>
        <li>false otherwise</li>
      </ul>
    </div>
    <%= rb_code "code/problems/longest_palindromic_substring/s2.rb" %>
    <%= complexity_table do %>
      Time   O(n^2)  Each of n^2 substrings takes O(1) time to check
      Space  O(n^2)  2D boolean array for n^2 substrings
    <% end %>
  </div>

  <div class="solution">
    <h2>Solution 3: Central expansion</h2>
    <div class="explanation">
      Iterate over all possible centers of palindromes.
      A center can begin either
      <ul>
        <li>on a character for odd-length palindromes</li>
        <li>between two characters for even-length palindromes</li>
      </ul>
      For each center, check if the first and last letter match.
      Keep expanding outwards if they do.
      Store the start and end string indices for the longest palindrome seen so far.
    </div>
    <%= rb_code "code/problems/longest_palindromic_substring/s3.rb" %>
    <%= complexity_table do %>
      Time   O(n^2)  Each of 2n - 1 centers takes O(n) time to check
      Space  O(1)    The start/ end indices of the longest palindrome
    <% end %>
  </div>

  <div class="solution">
    <h2>Solution 3: Manacher's algorithm</h2>
    <div class="explanation">
      This is an improvement over the central expansion algorithm.
    </div>
    <%= complexity_table do %>
      Time   O(n)
      Space  O(1)
    <% end %>
  </div>
</section>
