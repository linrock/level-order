<h1>Kth largest element in an array</h1>

<section class="problem">
  <div>Find the kth largest element in an array of numbers</div>

  <pre>
    [1, 8, 6, 10, 2]

    When k = 1, the 1st largest element is 10
    When k = 3, the 3rd largest element is 6
  </pre>
</section>

<%= solutions_table do %>
  Sorting             O(n log n)       O(1)
  Min-heap            O(n + k log n)   O(n)
  Max-heap            O(n log k)       O(k)
  Quickselect         O(n) to O(n^2)   O(1)
  Median of medians   O(n)             O(1)
<% end %>

<section class="solutions">
  <section class="solution">
    <h2>Solution 1: Sorting</h2>

    <%= solution_explanation do %>
      Sort the input elements and find the k-th largest element
      in the sorted array. This is fine when n is small, but fully
      sorting the array is doing a lot of unnecessary work in
      most cases. Plus you would want more-efficient solutions when
      n is large.
    <% end %>

    <%= rb_code "code/problems/kth_largest_element/s1.rb" %>
    <%= complexity_table do %>
      Time   O(n log n)
      Space  O(1)        In-place sorting
    <% end %>
  </section>

  <section class="solution">
    <h2>Solution 2: Max-heap</h2>

    <%= solution_explanation do %>
      We can put all the elements in the array into a max-heap
      and then pop k values from the heap to get the k-th largest
      element.

      Runtime analysis:

        * Building a max heap takes O(n) time and O(n) space
        * Finding the max element in the heap takes O(1) time
        * Removing the max element and fixing the heap order takes O(log n) time
        * Removing the max element k times would take O(k log n) time overall

      Looking at different values of k:

        * When k is large, the time complexity approaches O(n + n log n) ~ O(n log n)
        * When k is small, the time complexity approaches O(n + 1 log n) ~ O(n)
    <% end %>

    <%= complexity_table do %>
      Time   O(n + k log n)
      Space  O(n)            n elements in the heap
    <% end %>
  </section>

  <section class="solution">
    <h2>Solution 3: Min-heap</h2>

    <%= solution_explanation do %>
      Alternatively, we can use a min heap to save space and
      for the opposite behavior in time complexity as k changes.

      To find the k-th largest value:

        * We can create a min-heap with a max size of k
        * For each element in the array
          * If the heap is not yet full, put it into the heap
          * If the heap is full, add it if it's larger than the min value in the heap
        * Each of n insertions will take O(log k) time
        * The min value in the heap is the kth-largest element

    <% end %>

    <%= complexity_table do %>
      Time   O(n log k)
      Space  O(k)            k elements in the heap
    <% end %>
  </section>

  <section class="solution">
    <h2>Solution 4: Quickselect</h2>

    <%= solution_explanation do %>
      By only partially sorting the array, we can avoid doing
      unnecessary work and find the kth-largest element in O(n)
      time on average by using a selection algorithm.
    <% end %>

    <%= complexity_table do %>
      Time   O(n)  Worst case O(n^2) if you get unlucky
      Space  O(1)  In-place swapping of elements
    <% end %>
  </section>

  <section class="solution">
    <h2>Solution 5: Median of medians</h2>

    <%= solution_explanation do %>
      The previous solution used quickselect with random pivots, which
      randomly has poor worst-case if you get unlucky. By improving the
      way that pivots are chosen, we can eliminate the possibility of
      running into the worst-case performance scenario. The tradeoff is
      that we'll do slightly more work on average, but still in linear
      time.
    <% end %>

    <%= complexity_table do %>
      Time   O(n)
      Space  O(1)  In-place swapping of elements
    <% end %>
  </section>
</section>

<%= resources_section do %>
  Leetcode problem
  https://leetcode.com/problems/kth-largest-element-in-an-array/

  Wikipedia - Quickselect
  https://en.wikipedia.org/wiki/Quickselect

  Wikipedia - Floyd-Rivest algorithm
  https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm
<% end %>
