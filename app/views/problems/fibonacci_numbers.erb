<section class="problem">
  <h1>Fibonacci numbers</h1>

  <%= explanation do %>
    A fibonacci number is the sum of the two previous numbers
    in the sequence.

    These are the first 10 fibonacci numbers:  1 1 2 3 5 8 13 21 34 55
  <% end %>

  <%= code_inline do %>
    Input:   5
    Output:  5

    Input:   12
    Output:  144

    Input:   200
    Output:  280571172992510140037611932413038677189525
  <% end %>

  <%= explanation do %>
    Since the input to the fibonacci functions is a number, we have to consider
    the number of bits needed to represent the number when calculating time/space
    complexities.

    The number of bits needed to represent the n-th fibonacci number scales
    linearly with n, so we need to consider an extra O(n) factor when adding
    and storing fibonacci numbers.

    For reference:

    * The 10th fibonacci number has 6 bits
    * The 100th fibonacci number has 68 bits
    * The 1,000th fibonacci number has 693 bits
    * The 10,000th fibonacci number has 6,941 bits

  <% end %>
</section>

<%= solutions_table([:bad, :average, :average, :good, :great]) do %>
  Recursion            O(2^n n)    O(n^2)
  Memoization          O(n^2)      O(n^2)
  Dynamic programming  O(n^2)                O(n^2)
  Iterative            O(n^2)                O(n)
  Binet's formula      O(n log n log log n) to O(n^2)  O(n)
<% end %>

<section class="solutions">
  <section class="solution">
    <h2 class="bad">Solution 1: Recursion</h2>

    <div class="explanation">
    </div>
    <%= rb_code "code/problems/fibonacci_numbers/s1.rb" %>
    <%= complexity_table do %>
      Time   O(2^n n)  2x recursive calls at each of O(n) levels
      Space  O(n^2)   O(n) max stack depth with O(n) bits for the nth number
    <% end %>
  </section>

  <section class="solution">
    <h2 class="average">Solution 2: Memoization</h2>

    <div class="explanation">
    </div>
    <%= rb_code "code/problems/fibonacci_numbers/s2.rb" %>
    <%= complexity_table do %>
      Time   O(n^2)   O(n) stack depth adding O(n) bit numbers
      Space  O(n^2)   n-sized array of numbers with O(n) bits per number
    <% end %>
  </section>

  <section class="solution">
    <h2 class="average">Solution 3: Dynamic programming</h2>

    <div class="explanation">
    </div>
    <%= rb_code "code/problems/fibonacci_numbers/s3.rb" %>
    <%= complexity_table do %>
      Time   O(n^2)   O(n) loop adding O(n) bit numbers at each iteration
      Space  O(n^2)   n-size array of numbers with O(n) bits per number
    <% end %>
  </section>

  <section class="solution">
    <h2 class="good">Solution 4: Iterative</h2>

    <div class="explanation">
    </div>
    <%= rb_code "code/problems/fibonacci_numbers/s4.rb" %>
    <%= complexity_table do %>
      Time   O(n^2)   O(n) loop adding O(n) bit numbers at each iteration
      Space  O(n)     Two integers each containing O(n) bits
    <% end %>
  </section>

  <section class="solution">
    <h2 class="great">Solution 5: Binet's formula</h2>

    <%= explanation do %>
      Calculating a fibonacci number using this formula requires n multiplications
      of O(n) bit numbers. The runtime depends on the multiplication algorithm being
      used:

      * O(n^2) -               Regular long multiplication
      * O(n^1.585) -           Karatsuba algorithm
      * O(n^1.465) -           3-way Toom-Cook multiplication
      * O(n log n log log n) - Schonhage-Strassen algorithm

      In the worst case, multiplication is done the way we learned in school -
      multiplying each digit together and summing them up. The runtime is O(n^2),
      but in practice this algorithm would be slower than the O(n^2) addition algorithms
      because of performance penalties in floating-point arithmetic vs adding
      integers together.

      The best case happens with the Schonhage-Strassen algorithm, which in practice
      starts to outperform the other algorithms at astronomically large values of n
      (tens-of-thousands of digits).

      The floating point precision of standard libraries are typically not enough to
      handle the precision needed for large numbers of n. You'll need to use a library
      designed to handle these cases like the
      <a href="https://gmplib.org/">GNU multiple precision arithmetic library</a>
      if you want accurate calculations as n increases in size.
    <% end %>
    <%= rb_code "code/problems/fibonacci_numbers/s5.rb" %>
    <%= complexity_table do %>
      Time   O(n log n log log n) to O(n^2)  Varies depending on the multiplication algorithm used
      Space  O(n)                  Floating point numbers each of size O(n)
    <% end %>
  </section>
</section>

<%= resources_section do %>
  Wikipedia - Fibonacci numbers
  https://en.wikipedia.org/wiki/Fibonacci_number

  Wikipedia - computational complexity of math operations
  https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations
<% end %>
