<h1>Binary heap</h1>

<%= explanation do %>
  A complete binary tree where parent and child nodes are ordered
  in a specific way.

  * Max heap - the values of all parent nodes in the tree are larger
    than both of their child nodes.
  * Min heap - the values of all parent nodes in the tree are smaller
    than both of their child nodes.
<% end %>

<pre>
      3           1
     / \         / \
    2   4       2   3
   / \ /       / \ /
  1  9 10     5  9 7
</pre>

<%= explanation do %>
  Heaps let you efficiently access the largest or smallest
  elements in a list of elements.

  Typically, a heap is backed by an array. In a complete binary tree,
  you know where to look for the parent and children nodes from any given
  array index.

  From an array index i in a zero-indexed array

  * 2*i + 1 = the array index of the left child
  * 2*i + 2 = the array index of the right child
  * (i-1)/2 = the array index of the parent
<% end %>

<h2>Building a heap</h2>
<h3>Inserting each element</h3>
<%= explanation do %>
  You can insert each element into the heap one-at-a-time, and then
  restore the heap order to create a heap. This runs in O(n log n) time,
  since for each of n elements, restoring the heap order takes O(log n)
  time after you insert it.

  Process:

  * Add the element you want to insert to the end of the array
  * Sift up the last element in the array to restore the heap order
<% end %>
<%= rb_code "code/data_structures/binary_heap/sift_up.rb" %>

<h3>Floyd's algorithm</h3>
<div>
  Floyd's algorithm can create a heap-ordered array in O(n) time.
  Heapifying an array is arranging its elements in a heap-ordered way.
  Start with the lowest level in the tree with parent child nodes
  and work your way up the tree, sifting nodes down if they're out of
  order.
</div>
<%= rb_code "code/data_structures/binary_heap/heapify.rb" %>
<div>
  Sifting down makes sure that a node in a tree is heap-ordered.
  If the parent node is larger than any child node, swap the two
  values in the nodes. Then do the same for the swapped child node
  until the heap is back in order.
</div>
<%= rb_code "code/data_structures/binary_heap/sift_down.rb" %>

<h2>Min heap</h2>
<%= explanation do %>
  Basic things you might want to do with a min heap are

  * Insert - add a value into the heap
  * Pop - remove the min value from the heap
  * Min - look at the min value in the heap
<% end %>
<%= rb_code "code/data_structures/binary_heap/min_heap.rb" %>
<%= data_structure_complexity_table do %>
  Time   O(log n)  Insert  fixing heap-order when adding a value
         O(log n)  Pop     fixing heap-order when removing a value
         O(1)      Min     looking at the first value in the heap
  Space  O(n)
<% end %>
